# Week 3:


```python
#課程連結🔗：https://cs50.harvard.edu/college/2019/fall/weeks/3/
```

## Search

上一次，我們討論了計算機或RAM中的內存，以及如何將我們的數據存儲為單個變量或許多項目或元素的數組。

我們可以將具有多個項目的陣列視為一排儲物櫃，其中計算機只能一次打開一個儲物櫃來查看一個項目。

例如，如果我們要檢查數組中是否存在數字，並且使用將數組作為輸入並產生布爾值的算法，則可以：

從頭到尾一次查看每個儲物櫃或每個元素。

這就是所謂的線性搜索，因為數組未排序，因此我們在一行中移動。

從中間開始，然後根據要查找的內容向左或向右移動（如果我們對一系列商品進行了排序）。

這被稱為二進制搜索，因為我們可以將問題每一步都分成兩部分，就像David在第0週對電話簿所做的那樣。

## Big O

![](https://upload.cc/i1/2020/01/10/ItDivd.png)

更為正式的描述方式是使用大O符號，我們可以將其視為“按順序排列”。例如，如果我們的算法是線性搜索，則將採取大約O（n）的步驟，“約為n”。實際上，即使一次查看兩個項目並採取n / 2步的算法也具有O（n）。這是因為，隨著n越來越大，只有最大的項n才重要。

類似地，無論底數是多少，對數運行時間均為O（log n），因為這只是n很大時的近似值。


有一些常見的運行時間：

* O(n2)
* O(n log n)
* O(n)

         * (linear search)

* O(log n)

        * (binary search)

* O(1)

計算機科學家可能還會使用大Ω，大歐米茄（Omega）表示法，這是我們算法中步數的下限。 

（大O是步數的上限，或者是最壞的情況，通常是我們最關心的。）

例如，使用線性搜索，最壞的情況是n步，但是最好的情況是1步，因為我們的產品可能恰好是我們檢查的第一項。二進制搜索的最佳情況也是1，因為我們的項目可能在數組的中間。

我們有一組類似的最常見的大Ω運行時間：

* Ω(n2)
* Ω(n log n)
* Ω(n)
               * (counting the number of items)
* Ω(log n)
* Ω(1)
               * (linear search, binary search)



```python

```
