# BST原理：

「二元搜尋樹」(Binary Search Trees)是一棵二元樹，在這基礎上它或者是一棵空樹；或者是具有下列性質的二元樹：

（1）若左子樹不空，則左子樹上所有結點的值均小於它的根結點的值；

（2）若右子樹不空，則右子樹上所有結點的值均大於它的根結點的值；

（3）左、右子樹也分別為二元查找樹

它的功能有很多，例如新增、查找、刪除、修正等。




## 新增(Insert):

如果BST為空，则新增節點就當作根節點。

如果BST不為空，新增節點和根節點作比較，如果比根節點小，則和根節點的左子樹比較，這裡用recursive。

如果比根節點大則和右子樹作比較，也會用到recursive。直到沒有左子樹或者右子樹了，然後把新節點當作左子樹或者右子樹節點。

## 查詢(Search)：

若BST是空樹，則搜索失敗。

tagert和根節點比較，如果相等則root是查詢值。

如果tagert比根節點小，則遞迴查詢根節點的左子樹，直到當前node的值等於tagert。

如果tagert比根節點大，則遞迴查找根節點的右子樹，直到當前node的值等於tagert。

## 刪除(Delete)：

### 情況一：target為根節點

根節點只有左子樹。則刪除根節點，根節點的左小孩是新的根節點。

根節點只有右子樹。則刪除根節點，根節點的右小孩是新的根節點。

根節點有左右兩個子樹。可以找左子樹的最大值或者是右子樹的最大值代替。(我採用的方式是找右子樹的最大值，增加了一個FindMIn的函數)

根節點無左右子樹。直接刪掉根節點。

### 情況二：target不為根節點

根節點只有左子樹。則刪除根節點，根節點的左小孩是新的根節點。

根節點只有右子樹。則刪除根節點，根節點的右小孩是新的根節點。

根節點有左右兩個子樹。可以找左子樹的最大值或者是右子樹的最大值代替。

根節點無左右子樹。直接刪掉根節點。 此外，如果target不在樹當中，直接pass不改變原BST；如果有重複值，則依次刪掉重複值。

## 修改(Modify)：

修改後的BST的深度只能小於或者等於原BST的深度。 如果new_val不等於target，則先把new_val插入到BST當中，然後刪除target。 如果new_val和target相等，則直接return root即可。

、






參考資料：

https://blog.csdn.net/ShyTan/article/details/80984582 https://www.csie.ntu.edu.tw/~r95116/CA200/slide/C10_Tree.pdf
https://blog.csdn.net/li_l_il/article/details/88677927 https://blog.csdn.net/TTdreamloong/article/details/88673762
